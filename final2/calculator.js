// https://contest.yandex.ru/contest/22781/run-report/136569878/

// * опишите принцип работы вашего алгоритма; //
// Он описан дословно по условию задачи и в конце только надо вернуть число на вершине стека
// Копирую условия:
// Обработка входного символа:
// Если на вход подан операнд, он помещается на вершину стека.
// Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека в порядке добавления. Результат выполненной операции помещается на вершину стека.
// Если входной набор символов обработан не полностью, перейти к шагу 1.
// После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.

// * обоснуйте, почему он должен работать корректно; //
// потому что обратная польская нотация гарантирует, что порядок операций не зависит от скобок, а только от позиции оператора
// остальное переписала чисто из условия, тут думать не пришлось
// Стек позволяет корректно обрабатывать операции в нужном порядке,
// на каждом шаге стек содержит промежуточный результат, ну и в конце остаётся единственный элемент, он и будет ответом на задчу

// * оцените временную и пространственную сложность алгоритма. //
// время: О(N) - 1 раз проходимся по input; память - и O(n) в худшем случае (если просто числа серез пробел пришли, мы их все положим в созданный стек)

function isNumber(x) {
    return !isNaN(Number(x));
}

function sum (a, b) {
    return a + b;
}
function substraction (a, b) {
    return a - b;
}
function multiple (a, b) {
    return a * b;
}
function devide (a, b) {
    return Math.floor(a/b);
}



const operationMapper = {
    '+': sum,
    '-': substraction,
    '*': multiple,
    '/': devide,
};


function solve(_inputLines) {
    const input = _inputLines[0].split(' ');
    const stack = [];
    let result = null;

    for (let i = 0; i < input.length; i++) {
        const el = input[i];

        if (isNumber(el)) {
            stack.push(el);
        } else {
            const b = Number(stack.pop())
            const a = Number(stack.pop())
            result = operationMapper[el](a, b);

            stack.push(result);
        }
    }

    console.log(stack[stack.length - 1])
}


// solve(['2 1 + 3 *']);
// solve(`10 2 4 * -`.split('\n'));
// solve(`10 12`.split('\n'));
// solve(`7 2 + 4 * 2 +`.split('\n'));