// https://contest.yandex.ru/contest/23815/run-report/137487532/

// опишите принцип работы вашего алгоритма;
// в целом по логике просто имплементация условий из задачи, главное отличие от обычной быстрой сортировки из теоретической части, что мы  на каждом этапе рекурсии не на три "коробки" раскладываем элементы относительно pivot и возвращаем и соединяем эти три массива left, center и right, а возвращаем границу pivot, относительно которого все частично  отсортировано (слева меньше, справа больше чем pivot, например (если по возрастанию/неубыванию сортируем)) и далее повторяем действия сортировки относительно pivot рекурсивно пока есть больше 1 элемента.

// обоснуйте, почему он должен работать корректно;
// есть базовый случай когда массив состоит из 1 элемента или пустой - они уже отсортированы
// в ф-ции partition я очень долго пыталась и вроде сделала так, чтобы точно относительно pivot все элементы меньше чем pivot оказались слева, а справа были элементы больше pivot
// и к моменту как мы дойдем до базового случая массив будет отсортирован

// оцените временную и пространственную сложность алгоритма.

// Сложность по памяти - O(n) - плюс стек глубиной logn (бинарный подход в рекурсии, убирает в среднем половину массива за вызов рекурсии) - в худшем случе n => n + log n => тут наверняка можно пренебречь логарифмом, тк как он много меньше n => O(n)
// Алгоритмическая сложность - при чтении n, часть с разделением - log n, проход left вправо когда и идет а right влево - n, плюс localeCompare это k (средняя длина строки с именем). Итого О( n * log n * k). Оптимальность быстрой сортировки зависит от принципа выбора pivot и от того что из себя представлял изначальный массив. Худший случай будет n^2 вместо logn - это когда массив уже был отсортирован

// - Средняя временная сложность: O(n * log n * k),
//   где n — количество элементов, k — средняя длина строки (из-за localeCompare).
// - Худший случай по времени: O(n² * k), если на каждом шаге pivot оказывается крайним элементом, но у меня он вроде как всегда где-то по середине так как я выбираю среднее арифметическое между left и right
//   если массив уже отсортирован.
// - Пространственная сложность: O(log n) в среднем (за счёт глубины рекурсии).
//   В худшем случае — O(n), если не пополам примерно делится массив каждый раз, а на каждом шаге из-за неоптимально выбранного pivot массив будет делиться на 1 элемент и остальные, потом еще один добавляется и так надо по всему массиву будет пройтись n раз

function swap(arr, elIndex1, elIndex2) {
    [arr[elIndex1], arr[elIndex2]] = [arr[elIndex2], arr[elIndex1]];

    return arr;
}

// тут мы проверяем что левее (a) "лучше" того что правее (b) - т.е. должен быть в начале массива
// true - все ок, не меняем местами
function isFirstWin([nameA, doneA, feeA], [nameB, doneB, feeB]) {
    if (doneA > doneB) {
        return true;
    } else if (doneA === doneB && feeA !== feeB) {
        return feeA < feeB;
    } else if (doneA < doneB) {
        return false;
    }

    return nameA.toLowerCase().localeCompare(nameB.toLowerCase()) < 0;
}

function partition(arr, comparator, left, right) {
    if (!comparator) {
        comparator = (a, b) => {
            return a < b;
        }
    }

    const pivotIndex = Math.floor((left + right) / 2);
    const pivot = arr[pivotIndex];

    while (left <= right) {
        while (comparator(arr[left], pivot)) left++; // все ок, проверь сдвинь вправо и там проверь опять
        while (comparator(pivot, arr[right])) right--;  // все ок, проверь сдвинь влево и там проверь опять

        if (left <= right) {
            swap(arr, left, right);

            left++;
            right--;
        }
    }


    return left;
}

function quickSort(array = [], comparator, left = 0, right = array.length - 1) {
    if (left >= right) {
        return;
    }

    let pivot = partition(array, comparator, left, right);

    quickSort(array, comparator, left, pivot - 1);
    quickSort(array, comparator, pivot, right);
}



function solve() {
    let arr = [3,2,1]

    quickSort(arr);

    arr.forEach(r => console.log(r));
}


// solve();