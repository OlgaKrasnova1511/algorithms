// https://contest.yandex.ru/contest/23815/run-report/137262540/


// опишите принцип работы вашего алгоритма;
// привет) сразу на ум пришел обычный бинарный поиск, так как в данной задаче мы кое-что ищем, а именно конкретное число и повторов в числах в условии нет
// проблема одна - бинарный поиск работает только для отсортированного массива
// ограничение у задачи, что сложность logN, а это сразу убирает все варианты сортировок - у них сложность nlogn, ну и сортировка подсчетом не подходит, тк мы не знаем range значений
// этот массив отсортирован, но сломан в одном месте, чтобы узнать попал ли mid в отсортированную часть можно mid сравнить, например, с left
// надо сразу определить базовый случай - это если границы встретились
// нужно только "докрутить" условия поиска в нормально отсортированном массиве

// ===============================================================================================

// обоснуйте, почему он должен работать корректно;
// потому что сравнив mid с left мы поймем где "поломка" последовательности элементов и можем точно понять
// какую половину можно выкинуть из зоны поиска
// допустим мы видим [6.....2.....4] - это left mid right
// и k например 1, 8 или 3
// left больше mid, а занчит обрыв слева от mid
// k=1 в этой части [6.....2] - отрезаем и забываем правую часть
// k=8 в этой части [6.....2] -  отрезаем и забываем правую часть
// k=3 в этой части [2.....4] -  отрезаем и забываем левую часть

//если left < mid - разрыв последовательности справа
// и мы, добавив условия, также можем понять где примерно k
// например mid === 8 [6.....8.....4]
// k=1 в этой части [8.....4] -  отрезаем и забываем левую часть
// k=3 в этой части [8.....4] -  отрезаем и забываем левую часть
// k=7 в этой части [6.....8] -  отрезаем и забываем правую часть

// ============================================================================================

// оцените временную и пространственную сложность алгоритма.
// Сложность:
// У бинарного поиска очень оптимальная скорость роста числа необходимых операций при росте входных данных - логарифмическая сложность (о-большое) - log n
// попробую сделать с помощью рекурсии (так как мы ее только что прошли и еще я невероятно слаба в рекурсиях и это не исправить:) )
// По памяти - буду искать "на месте" (не создавая массив или каких либо других крупных структур данных), так что О(1)
// так же, вероятно, понадобятся переменные для примитивов - границ поиска - это тоже O(1) - тут опечатлась (тоже это О(1))
// плюс затраты на хванение стека рекурсии (глубина рекурсии) - logn



function binarySearch(arr, k, left, right) {
    // тут все "по-классике"
    if (left > right) return -1;

    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === k) {
        return mid;
    }
    // тут условия для границ, чтобы работало в этом сломаном массиве

    if (arr[left] <= arr[mid]) {
        if (k >= arr[left] && k < arr[mid]) {
            return binarySearch(arr, k, left, mid - 1);
        } else {
            return binarySearch(arr, k, mid + 1, right);
        }
    } else {
        if (k > arr[mid] && k <= arr[right]) {
            return binarySearch(arr, k, mid + 1, right);
        } else {
            return binarySearch(arr, k, left, mid - 1);
        }
    }
}

function brokenSearch(arr, k) {
    return binarySearch(arr, k, 0, arr.length - 1);
}




















function test() {
    // const arr = [19, 21, 100, 101, 1, 4, 5, 7, 12];
    const arr = [5, 1];
    console.log(brokenSearch(arr, 1));

    // if (brokenSearch(arr, 5) !== 6)  {
    //     console.error("WA");
    // }
}

test();